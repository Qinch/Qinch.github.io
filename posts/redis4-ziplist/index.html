<!DOCTYPE html>
<html lang="zh-cn">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title> - Just For Fun</title>
  <meta property="og:title" content=" - Just For Fun" />
  <meta name="twitter:title" content=" - Just For Fun" />
  <meta name="description" content="title: redis4.0_ziplist源码剖析
category: redis
date: 2017-12-03
tags: [redis4.0,ziplist,sourcecode]
toc: false
comments: true
1.ziplist
1.1.ziplist概述
The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers(integer内存表示) instead of a series of characters（ASCII码）. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.
1.2.ziplist整体内存布局

 |-----------|----------|---------|---------|---------|----|----------|---------|
 | &lt;zlbytes&gt; | &lt;zltail&gt; | &lt;zllen&gt; | &lt;entry0&gt;| &lt;entry1&gt;| ...| &lt;entryn&gt; | &lt;zlend&gt; |
 |-----------|----------|---------|---------|---------|----|----------|---------|
 |低地址            &lt;----------------------------                       高地址  |

NOTE: all fields are stored in little endian(即：低位在地地址，高位在高地址), if not specified otherwise.

The general layout of the ziplist is as follows:
&lt;uint32_t zlbytes&gt;用于记录整个ziplist占用的内存字节数；
&lt;uint32_t zltail&gt;用于记录最后一个节点(the last entry)的首地址距离ziplist首地址的偏移量;
&lt;uint16_t zllen&gt;用于记录ziplist中节点(entry)数量;
&lt;uint8_t  zlend&gt;用于表示ziplist的结尾,为定制 0xFF;

1.2.ziplist中entry内存布局
           
 |--------|----------|---------|
 | prelen | encoding | content |
 |--------|----------|---------|
 |低地址  &lt;----------   高地址 |

NOTE：a complete entry is stored like above(content长度可能为0,即一个entry可能只有prelen和encoding字段，没有content字段).
1.2.1 entry每个字段的含义:

prevlen字段用于记录前一个ziplist节点(entry)的长度，该字段以字节为单位。
如果前一个节点的长度小于255个字节，则prelen属性的长度为1bytes，该字节用于保存前一个节点的长度；
如果前一个节点的长度大于或等于255个字节，则prelen字段的长度为5bytes,其中第一个bytes为定制0xFF,之后的四个bytes用于保存前一个节点的长度；

1.2.2 encoding字段的含义：

encoding字段用于表示content字段所保存的数据的类型(string or int)以及content的长度。
encoding表示string类型及长度：
当encoding表示string类型时，encoding长度可能为1bytes,2bytes,5bytes,其中最低地址的头两个bits为非11（即(?? &amp; 11) &lt; 11）
当encoding编码为 00bb bbbb（二进制） 时，encoding字段的长度为1bytes,content的长度小于等于0x3F的字节数组;
当encoding编码为 01bb bbbb bbbb bbbb（二进制） 时，encoding字段的长度为2bytes（其中encoding中bb bbbb bbbb bbbb表示string的长度，即content的长度，采用big endian表示）,content的长度为小于等于0x3FFF的字节数组;
当encoding编码为10__ ____ aaaa aaaa bbbb bbbb cccc cccc dddd dddd （二进制）时,encoding字段的长度为5bytes(其中encoding中aaaaaaaa bbbbbbbb cccccccc dddddddd表示string的长度,采用big endian表示),content的长度为小于等于0xFFFFFFFF的字节数组;
encoding表示int*_t类型及长度：
当encoding表示integer类型时,encoding字段的长度为1bytes，最低地址的头两个bits为11(即encoding为(11?? ????));
当encoding的编码为 1100 0000(二进制)时,content的长度与2bytes,即表示int16_t类型
当encoding的编码为 1101 0000(二进制)时,content的长度与4bytes,即表示int32_t类型
当encoding的编码为 1110 0000(二进制)时,content的长度与8bytes,即表示int64_t类型
当encoding的编码为 1110 0000(二进制)时,content的长度与3bytes,即表示int24_t类型
当encoding的编码为 1111 1110(二进制)时,content的长度与1bytes,即表示int8_t类型
当encoding的编码为 1100 xxxx(二进制)时,content的长度与0bytes,即表示immediate 4 bit integer,其中xxxx 4bits表示[0,12](encoding的编码范围为1111 0001~1111 1101);
|11111111| - End of ziplist special entry.
">
  <meta property="og:description" content="title: redis4.0_ziplist源码剖析
category: redis
date: 2017-12-03
tags: [redis4.0,ziplist,sourcecode]
toc: false
comments: true
1.ziplist
1.1.ziplist概述
The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers(integer内存表示) instead of a series of characters（ASCII码）. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.
1.2.ziplist整体内存布局

 |-----------|----------|---------|---------|---------|----|----------|---------|
 | &lt;zlbytes&gt; | &lt;zltail&gt; | &lt;zllen&gt; | &lt;entry0&gt;| &lt;entry1&gt;| ...| &lt;entryn&gt; | &lt;zlend&gt; |
 |-----------|----------|---------|---------|---------|----|----------|---------|
 |低地址            &lt;----------------------------                       高地址  |

NOTE: all fields are stored in little endian(即：低位在地地址，高位在高地址), if not specified otherwise.

The general layout of the ziplist is as follows:
&lt;uint32_t zlbytes&gt;用于记录整个ziplist占用的内存字节数；
&lt;uint32_t zltail&gt;用于记录最后一个节点(the last entry)的首地址距离ziplist首地址的偏移量;
&lt;uint16_t zllen&gt;用于记录ziplist中节点(entry)数量;
&lt;uint8_t  zlend&gt;用于表示ziplist的结尾,为定制 0xFF;

1.2.ziplist中entry内存布局
           
 |--------|----------|---------|
 | prelen | encoding | content |
 |--------|----------|---------|
 |低地址  &lt;----------   高地址 |

NOTE：a complete entry is stored like above(content长度可能为0,即一个entry可能只有prelen和encoding字段，没有content字段).
1.2.1 entry每个字段的含义:

prevlen字段用于记录前一个ziplist节点(entry)的长度，该字段以字节为单位。
如果前一个节点的长度小于255个字节，则prelen属性的长度为1bytes，该字节用于保存前一个节点的长度；
如果前一个节点的长度大于或等于255个字节，则prelen字段的长度为5bytes,其中第一个bytes为定制0xFF,之后的四个bytes用于保存前一个节点的长度；

1.2.2 encoding字段的含义：

encoding字段用于表示content字段所保存的数据的类型(string or int)以及content的长度。
encoding表示string类型及长度：
当encoding表示string类型时，encoding长度可能为1bytes,2bytes,5bytes,其中最低地址的头两个bits为非11（即(?? &amp; 11) &lt; 11）
当encoding编码为 00bb bbbb（二进制） 时，encoding字段的长度为1bytes,content的长度小于等于0x3F的字节数组;
当encoding编码为 01bb bbbb bbbb bbbb（二进制） 时，encoding字段的长度为2bytes（其中encoding中bb bbbb bbbb bbbb表示string的长度，即content的长度，采用big endian表示）,content的长度为小于等于0x3FFF的字节数组;
当encoding编码为10__ ____ aaaa aaaa bbbb bbbb cccc cccc dddd dddd （二进制）时,encoding字段的长度为5bytes(其中encoding中aaaaaaaa bbbbbbbb cccccccc dddddddd表示string的长度,采用big endian表示),content的长度为小于等于0xFFFFFFFF的字节数组;
encoding表示int*_t类型及长度：
当encoding表示integer类型时,encoding字段的长度为1bytes，最低地址的头两个bits为11(即encoding为(11?? ????));
当encoding的编码为 1100 0000(二进制)时,content的长度与2bytes,即表示int16_t类型
当encoding的编码为 1101 0000(二进制)时,content的长度与4bytes,即表示int32_t类型
当encoding的编码为 1110 0000(二进制)时,content的长度与8bytes,即表示int64_t类型
当encoding的编码为 1110 0000(二进制)时,content的长度与3bytes,即表示int24_t类型
当encoding的编码为 1111 1110(二进制)时,content的长度与1bytes,即表示int8_t类型
当encoding的编码为 1100 xxxx(二进制)时,content的长度与0bytes,即表示immediate 4 bit integer,其中xxxx 4bits表示[0,12](encoding的编码范围为1111 0001~1111 1101);
|11111111| - End of ziplist special entry.
">
  <meta name="twitter:description" content="title: redis4.0_ziplist源码剖析
category: redis
date: 2017-12-03
tags: [redis4.0,ziplist,sourcecode]
toc: false
comments: true
1.ziplist
1.1.ziplist概述
The ziplist is a specially encoded dually linked list …">
  <meta name="author" content=""/>
  <meta property="og:site_name" content="Just For Fun" />
  <meta property="og:url" content="http://localhost:1313/posts/redis4-ziplist/" />
  <meta property="og:type" content="article" />
  <meta name="twitter:card" content="summary" />
  <meta name="generator" content="Hugo 0.125.5">
  <link rel="stylesheet" href="/css/style.css" media="all" />
  <link rel="stylesheet" href="/css/style-dark.css" media="all and (prefers-color-scheme: dark)" />

  <link rel="stylesheet" href="/css/syntax.css" media="all" />
  <link rel="stylesheet" href="/css/custom.css" media="all" />

  <script src="/js/script.js"></script>
  <script src="/js/custom.js"></script>
  <script defer src="/fontawesome/all.min.js"></script>
</head>

<body>

<header class="site-header">
  <nav class="site-navi">
    <h1 class="site-title"><a href="/">Just For Fun</a></h1>
    <ul class="site-navi-items">
      <li class="site-navi-item-categories"><a href="/categories/" title="Categories">Categories</a></li>
      <li class="site-navi-item-archives"><a href="/archives/" title="Archives">Archives</a></li>
      <li class="site-navi-item-about"><a href="/about/" title="About">About</a></li>
    </ul>
  </nav>
</header>
<hr class="site-header-bottom">

  <div class="main" role="main">
    <article class="article">
      
      
      <h1 class="article-title"></h1>
      
      <hr class="article-title-bottom">
      <ul class="article-meta">
        <li class="article-meta-date"><time>January 1, 0001</time></li>
      </ul>
      
<aside class="toc">
  <nav id="TableOfContents">
  <ul>
    <li><a href="#comments-true">title: redis4.0_ziplist源码剖析
category: redis
date: 2017-12-03
tags: [redis4.0,ziplist,sourcecode]
toc: false
comments: true</a>
      <ul>
        <li><a href="#1ziplist">1.ziplist</a></li>
        <li><a href="#2ziplistc源码分析">2.ziplist.c.源码分析</a></li>
      </ul>
    </li>
  </ul>
</nav>
</aside>
      <h2 id="comments-true">title: redis4.0_ziplist源码剖析
category: redis
date: 2017-12-03
tags: [redis4.0,ziplist,sourcecode]
toc: false
comments: true</h2>
<h3 id="1ziplist">1.ziplist</h3>
<h4 id="11ziplist概述">1.1.ziplist概述</h4>
<p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers(integer内存表示) instead of a series of characters（ASCII码）. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</p>
<h4 id="12ziplist整体内存布局">1.2.ziplist整体内存布局</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> |-----------|----------|---------|---------|---------|----|----------|---------|
</span></span><span style="display:flex;"><span> | &lt;zlbytes&gt; | &lt;zltail&gt; | &lt;zllen&gt; | &lt;entry0&gt;| &lt;entry1&gt;| ...| &lt;entryn&gt; | &lt;zlend&gt; |
</span></span><span style="display:flex;"><span> |-----------|----------|---------|---------|---------|----|----------|---------|
</span></span><span style="display:flex;"><span> |低地址            &lt;----------------------------                       高地址  |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NOTE: all fields are stored in little endian<span style="color:#f92672">(</span>即：低位在地地址，高位在高地址<span style="color:#f92672">)</span>, <span style="color:#66d9ef">if</span> not specified otherwise.
</span></span></code></pre></div><ul>
<li>The general layout of the ziplist is as follows:</li>
<li>&lt;uint32_t zlbytes&gt;用于记录整个ziplist占用的内存字节数；</li>
<li>&lt;uint32_t zltail&gt;用于记录最后一个节点(the last entry)的首地址距离ziplist首地址的偏移量;</li>
<li>&lt;uint16_t zllen&gt;用于记录ziplist中节点(entry)数量;</li>
<li>&lt;uint8_t  zlend&gt;用于表示ziplist的结尾,为定制 0xFF;</li>
</ul>
<h5 id="12ziplist中entry内存布局">1.2.ziplist中entry内存布局</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>           
</span></span><span style="display:flex;"><span> |--------|----------|---------|
</span></span><span style="display:flex;"><span> | prelen | encoding | content |
</span></span><span style="display:flex;"><span> |--------|----------|---------|
</span></span><span style="display:flex;"><span> |低地址  &lt;----------   高地址 |
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>NOTE：a complete entry is stored like above<span style="color:#f92672">(</span>content长度可能为0,即一个entry可能只有prelen和encoding字段，没有content字段<span style="color:#f92672">)</span>.
</span></span></code></pre></div><h5 id="121-entry每个字段的含义">1.2.1 entry每个字段的含义:</h5>
<ul>
<li>prevlen字段用于记录前一个ziplist节点(entry)的长度，该字段以字节为单位。</li>
<li>如果前一个节点的长度小于255个字节，则prelen属性的长度为1bytes，该字节用于保存前一个节点的长度；</li>
<li>如果前一个节点的长度大于或等于255个字节，则prelen字段的长度为5bytes,其中第一个bytes为定制0xFF,之后的四个bytes用于保存前一个节点的长度；</li>
</ul>
<h5 id="122-encoding字段的含义">1.2.2 encoding字段的含义：</h5>
<ul>
<li>encoding字段用于表示content字段所保存的数据的类型(string or int)以及content的长度。</li>
<li>encoding表示string类型及长度：</li>
<li>当encoding表示string类型时，encoding长度可能为1bytes,2bytes,5bytes,其中最低地址的头两个bits为非11（即(?? &amp; 11) &lt; 11）</li>
<li>当encoding编码为 00bb bbbb（二进制） 时，encoding字段的长度为1bytes,content的长度小于等于0x3F的字节数组;</li>
<li>当encoding编码为 01bb bbbb bbbb bbbb（二进制） 时，encoding字段的长度为2bytes（其中encoding中bb bbbb bbbb bbbb表示string的长度，即content的长度，采用big endian表示）,content的长度为小于等于0x3FFF的字节数组;</li>
<li>当encoding编码为10__ ____ aaaa aaaa bbbb bbbb cccc cccc dddd dddd （二进制）时,encoding字段的长度为5bytes(其中encoding中aaaaaaaa bbbbbbbb cccccccc dddddddd表示string的长度,采用big endian表示),content的长度为小于等于0xFFFFFFFF的字节数组;</li>
<li>encoding表示int*_t类型及长度：</li>
<li>当encoding表示integer类型时,encoding字段的长度为1bytes，最低地址的头两个bits为11(即encoding为(11?? ????));</li>
<li>当encoding的编码为 1100 0000(二进制)时,content的长度与2bytes,即表示int16_t类型</li>
<li>当encoding的编码为 1101 0000(二进制)时,content的长度与4bytes,即表示int32_t类型</li>
<li>当encoding的编码为 1110 0000(二进制)时,content的长度与8bytes,即表示int64_t类型</li>
<li>当encoding的编码为 1110 0000(二进制)时,content的长度与3bytes,即表示int24_t类型</li>
<li>当encoding的编码为 1111 1110(二进制)时,content的长度与1bytes,即表示int8_t类型</li>
<li>当encoding的编码为 1100 xxxx(二进制)时,content的长度与0bytes,即表示immediate 4 bit integer,其中xxxx 4bits表示[0,12](encoding的编码范围为1111 0001~1111 1101);</li>
<li>|11111111| - End of ziplist special entry.</li>
</ul>
<h3 id="2ziplistc源码分析">2.ziplist.c.源码分析</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>/* The ziplist is a specially encoded dually linked list that is designed
</span></span><span style="display:flex;"><span> * to be very memory efficient. It stores both strings and integer values,
</span></span><span style="display:flex;"><span> * where integers are encoded as actual integers instead of a series of
</span></span><span style="display:flex;"><span> * characters. It allows push and pop operations on either side of the list
</span></span><span style="display:flex;"><span> * in O<span style="color:#f92672">(</span>1<span style="color:#f92672">)</span> time. However, because every operation requires a reallocation of
</span></span><span style="display:flex;"><span> * the memory used by the ziplist, the actual complexity is related to the
</span></span><span style="display:flex;"><span> * amount of memory used by the ziplist.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * ----------------------------------------------------------------------------
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * ZIPLIST OVERALL LAYOUT
</span></span><span style="display:flex;"><span> * <span style="color:#f92672">======================</span>
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * The general layout of the ziplist is as follows:
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * &lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * NOTE:如果没有特殊说明，所有fields采用小端法表示，即：低位在低地址。
</span></span><span style="display:flex;"><span> * NOTE: all fields are stored in little endian, <span style="color:#66d9ef">if</span> not specified otherwise.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * &lt;uint32_t zlbytes&gt; is an unsigned integer to hold the number of bytes that
</span></span><span style="display:flex;"><span> * the ziplist occupies, including the four bytes of the zlbytes field itself.
</span></span><span style="display:flex;"><span> * This value needs to be stored to be able to resize the entire structure
</span></span><span style="display:flex;"><span> * without the need to traverse it first.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * &lt;uint32_t zltail&gt; is the offset to the last entry in the list. This allows
</span></span><span style="display:flex;"><span> * a pop operation on the far side of the list without the need <span style="color:#66d9ef">for</span> full
</span></span><span style="display:flex;"><span> * traversal.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * &lt;uint16_t zllen&gt; is the number of entries. When there are more than
</span></span><span style="display:flex;"><span> * 2^16-2 entires, this value is set to 2^16-1 and we need to traverse the
</span></span><span style="display:flex;"><span> * entire list to know how many items it holds.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * &lt;uint8_t zlend&gt; is a special entry representing the end of the ziplist.
</span></span><span style="display:flex;"><span> * Is encoded as a single byte equal to 255. No other normal entry starts
</span></span><span style="display:flex;"><span> * with a byte set to the value of 255.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * ZIPLIST ENTRIES
</span></span><span style="display:flex;"><span> * <span style="color:#f92672">===============</span>
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * Every entry in the ziplist is prefixed by metadata that contains two pieces
</span></span><span style="display:flex;"><span> * of information. First, the length of the previous entry is stored to be
</span></span><span style="display:flex;"><span> * able to traverse the list from back to front. Second, the entry encoding is
</span></span><span style="display:flex;"><span> * provided. It represents the entry type, integer or string, and in the <span style="color:#66d9ef">case</span>
</span></span><span style="display:flex;"><span> * of strings it also represents the length of the string payload.
</span></span><span style="display:flex;"><span> * So a complete entry is stored like this:
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * &lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * Sometimes the encoding represents the entry itself, like <span style="color:#66d9ef">for</span> small integers
</span></span><span style="display:flex;"><span> * as we<span style="color:#e6db74">&#39;ll see later. In such a case the &lt;entry-data&gt; part is missing, and we
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * could have just:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * &lt;prevlen&gt; &lt;encoding&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The length of the previous entry, &lt;prevlen&gt;, is encoded in the following way:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * If this length is smaller than 255 bytes, it will only consume a single
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * byte representing the length as an unsinged 8 bit integer. When the length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * is greater than or equal to 255, it will consume 5 bytes. The first byte is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * set to 255 (FF) to indicate a larger value is following. The remaining 4
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * bytes take the length of the previous entry as value.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * So practically an entry is encoded in the following way:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * &lt;prevlen from 0 to 254&gt; &lt;encoding&gt; &lt;entry&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Or alternatively if the previous entry length is greater than 254 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * the following encoding is used:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * 0xFF &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The encoding field of the entry depends on the content of the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * entry. When the entry is a string, the first 2 bits of the encoding first
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * byte will hold the type of encoding used to store the length of the string,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * followed by the actual length of the string. When the entry is an integer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * the first 2 bits are both set to 1. The following 2 bits are used to specify
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * what kind of integer will be stored after this header. An overview of the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * different types and encodings is as follows. The first byte is always enough
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * to determine the kind of entry.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |00pppppp| - 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      String value with length less than or equal to 63 bytes (6 bits).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      &#34;pppppp&#34; represents the unsigned 6 bit length.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |01pppppp|qqqqqqqq| - 2 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      String value with length less than or equal to 16383 bytes (14 bits).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      IMPORTANT: The 14 bit number is stored in big endian.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      String value with length greater than or equal to 16384 bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Only the 4 bytes following the first byte represents the length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      up to 32^2-1. The 6 lower bits of the first byte are not used and
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      are set to zero.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      IMPORTANT: The 32 bit number is stored in big endian.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |11000000| - 3 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Integer encoded as int16_t (2 bytes).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |11010000| - 5 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Integer encoded as int32_t (4 bytes).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |11100000| - 9 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Integer encoded as int64_t (8 bytes).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |11110000| - 4 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Integer encoded as 24 bit signed (3 bytes).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |11111110| - 2 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Integer encoded as 8 bit signed (1 byte).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |1111xxxx| - (with xxxx between 0000 and 1101) immediate 4 bit integer.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      Unsigned integer from 0 to 12. The encoded value is actually from
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      1 to 13 because 0000 and 1111 can not be used, so 1 should be
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *      subtracted from the encoded 4 bit value to obtain the right value.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |11111111| - End of ziplist special entry.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Like for the ziplist header, all the integers(int_*) are represented in little
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * endian byte order, even when this code is compiled in big endian systems.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * EXAMPLES OF ACTUAL ZIPLISTS
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * ===========================
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The following is a ziplist containing the two elements representing
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * the strings &#34;2&#34; and &#34;5&#34;. It is composed of 15 bytes, that we visually
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * split into sections:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *  [0f 00 00 00] [0c 00 00 00] [02 00] [00 f3] [02 f6] [ff]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *        |             |          |       |       |     |
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *     zlbytes        zltail    entries   &#34;2&#34;     &#34;5&#34;   end
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The first 4 bytes represent the number 15, that is the number of bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * the whole ziplist is composed of. The second 4 bytes are the offset
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * at which the last ziplist entry is found, that is 12, in fact the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * last entry, that is &#34;5&#34;, is at offset 12 inside the ziplist.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The next 16 bit integer represents the number of elements inside the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * ziplist, its value is 2 since there are just two elements inside.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Finally &#34;00 f3&#34; is the first entry representing the number 2. It is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * composed of the previous entry length, which is zero because this is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * our first entry, and the byte F3 which corresponds to the encoding
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * |1111xxxx| with xxxx between 0001 and 1101. We need to remove the &#34;F&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * higher order bits 1111, and subtract 1 from the &#34;3&#34;, so the entry value
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * is &#34;2&#34;. The next entry has a prevlen of 02, since the first entry is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * composed of exactly two bytes. The entry itself, F6, is encoded exactly
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * like the first entry, and 6-1 = 5, so the value of the entry is 5.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Finally the special entry FF signals the end of the ziplist.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Adding another element to the above string with the value &#34;Hello World&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * allows us to show how the ziplist encodes small strings. We&#39;</span>ll just show
</span></span><span style="display:flex;"><span> * the hex dump of the entry itself. Imagine the bytes as following the
</span></span><span style="display:flex;"><span> * entry that stores <span style="color:#e6db74">&#34;5&#34;</span> in the ziplist above:
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * <span style="color:#f92672">[</span>02<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>0b<span style="color:#f92672">]</span> <span style="color:#f92672">[</span><span style="color:#ae81ff">48</span> <span style="color:#ae81ff">65</span> 6c 6c 6f <span style="color:#ae81ff">20</span> <span style="color:#ae81ff">57</span> 6f <span style="color:#ae81ff">72</span> 6c 64<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * The first byte, 02, is the length of the previous entry. The next
</span></span><span style="display:flex;"><span> * byte represents the encoding in the pattern |00pppppp| that means
</span></span><span style="display:flex;"><span> * that the entry is a string of length &lt;pppppp&gt;, so 0B means that
</span></span><span style="display:flex;"><span> * an <span style="color:#ae81ff">11</span> bytes string follows. From the third byte <span style="color:#f92672">(</span>48<span style="color:#f92672">)</span> to the last <span style="color:#f92672">(</span>64<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> * there are just the ASCII characters <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#34;Hello World&#34;</span>.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * ----------------------------------------------------------------------------
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * Copyright <span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> 2009-2012, Pieter Noordhuis &lt;pcnoordhuis at gmail dot com&gt;
</span></span><span style="display:flex;"><span> * Copyright <span style="color:#f92672">(</span>c<span style="color:#f92672">)</span> 2009-2017, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;
</span></span><span style="display:flex;"><span> * All rights reserved.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * Redistribution and use in source and binary forms, with or without
</span></span><span style="display:flex;"><span> * modification, are permitted provided that the following conditions are met:
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> *   * Redistributions of source code must retain the above copyright notice,
</span></span><span style="display:flex;"><span> *     this list of conditions and the following disclaimer.
</span></span><span style="display:flex;"><span> *   * Redistributions in binary form must reproduce the above copyright
</span></span><span style="display:flex;"><span> *     notice, this list of conditions and the following disclaimer in the
</span></span><span style="display:flex;"><span> *     documentation and/or other materials provided with the distribution.
</span></span><span style="display:flex;"><span> *   * Neither the name of Redis nor the names of its contributors may be used
</span></span><span style="display:flex;"><span> *     to endorse or promote products derived from this software without
</span></span><span style="display:flex;"><span> *     specific prior written permission.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS <span style="color:#e6db74">&#34;AS IS&#34;</span>
</span></span><span style="display:flex;"><span> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
</span></span><span style="display:flex;"><span> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
</span></span><span style="display:flex;"><span> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
</span></span><span style="display:flex;"><span> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
</span></span><span style="display:flex;"><span> * CONSEQUENTIAL DAMAGES <span style="color:#f92672">(</span>INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
</span></span><span style="display:flex;"><span> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
</span></span><span style="display:flex;"><span> * INTERRUPTION<span style="color:#f92672">)</span> HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
</span></span><span style="display:flex;"><span> * CONTRACT, STRICT LIABILITY, OR TORT <span style="color:#f92672">(</span>INCLUDING NEGLIGENCE OR OTHERWISE<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
</span></span><span style="display:flex;"><span> * POSSIBILITY OF SUCH DAMAGE.
</span></span><span style="display:flex;"><span> */
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdio.h&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdlib.h&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;string.h&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;stdint.h&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &lt;limits.h&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;zmalloc.h&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;util.h&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;ziplist.h&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;endianconv.h&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include &#34;redisassert.h&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//zlend的值
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_END 255         /* Special &#34;end of ziplist&#34; entry. */</span>
</span></span><span style="display:flex;"><span>//该值用于判断prelen 字段的长度是1byte or <span style="color:#ae81ff">5</span> bytes
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_BIG_PREVLEN 254 /* Max number of bytes of the previous entry, for</span>
</span></span><span style="display:flex;"><span>                               the <span style="color:#e6db74">&#34;prevlen&#34;</span> field prefixing each entry, to be
</span></span><span style="display:flex;"><span>                               represented with just a single byte. Otherwise
</span></span><span style="display:flex;"><span>                               it is represented as FF AA BB CC DD, where
</span></span><span style="display:flex;"><span>                               AA BB CC DD are a <span style="color:#ae81ff">4</span> bytes unsigned integer
</span></span><span style="display:flex;"><span>                               representing the previous entry len. */
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Different encoding/length possibilities */
</span></span><span style="display:flex;"><span>//用于判断entry是str还是int
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_MASK 0xc0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//用于判断int类型（int_16, int_24, int_32, int_64）
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_MASK 0x30</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_06B (0 &lt;&lt; 6) //00 000000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_14B (1 &lt;&lt; 6) //01 000000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_STR_32B (2 &lt;&lt; 6) //10 000000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_16B (0xc0 | 0&lt;&lt;4) //1100 0000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_32B (0xc0 | 1&lt;&lt;4) //1101 0000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_64B (0xc0 | 2&lt;&lt;4) //1110 0000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_24B (0xc0 | 3&lt;&lt;4) //1111 0000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_8B 0xfe //1111 1110</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* <span style="color:#ae81ff">4</span> bit integer immediate encoding |1111xxxx| with xxxx between
</span></span><span style="display:flex;"><span> * <span style="color:#ae81ff">0001</span> and 1101. */
</span></span><span style="display:flex;"><span>//用于获取immedate <span style="color:#ae81ff">4</span> bit integer的值
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_IMM_MASK 0x0f   /* Mask to extract the 4 bits value. To add</span>
</span></span><span style="display:flex;"><span>                                   one is needed to reconstruct the value. */
</span></span><span style="display:flex;"><span>//最小值为<span style="color:#f92672">(</span>0xF1&amp;0x0F<span style="color:#f92672">)</span> - <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_IMM_MIN 0xf1    /* 11110001 */</span>
</span></span><span style="display:flex;"><span>//最大值为<span style="color:#f92672">(</span>0xFD&amp;0x0F<span style="color:#f92672">)</span> - <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_INT_IMM_MAX 0xfd    /* 11111101 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//24bits表示有符号整数，24bits解析为有符号整数，如果感兴趣，请浏览http://qinch.github.io/2016/01/10/bits-int/
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define INT24_MAX 0x7fffff</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define INT24_MIN (-INT24_MAX - 1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Macro to determine <span style="color:#66d9ef">if</span> the entry is a string. String entries never start
</span></span><span style="display:flex;"><span> * with <span style="color:#e6db74">&#34;11&#34;</span> as most significant bits of the first byte. */
</span></span><span style="display:flex;"><span>//判断encoding编码是不是string类型
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_IS_STR(enc) (((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Utility macros.*/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return total bytes a ziplist is composed of. */
</span></span><span style="display:flex;"><span>//获得ziplist的总长度，单位为byte
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the offset of the last item inside the ziplist. */
</span></span><span style="display:flex;"><span>//最后一个entry首地址距离ziplist首地址的偏移量
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the length of a ziplist, or UINT16_MAX <span style="color:#66d9ef">if</span> the length cannot be
</span></span><span style="display:flex;"><span> * determined without scanning the whole ziplist. */
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* The size of a ziplist header: two <span style="color:#ae81ff">32</span> bit integers <span style="color:#66d9ef">for</span> the total
</span></span><span style="display:flex;"><span> * bytes count and last item offset. One <span style="color:#ae81ff">16</span> bit integer <span style="color:#66d9ef">for</span> the number
</span></span><span style="display:flex;"><span> * of items field. */
</span></span><span style="display:flex;"><span>//ziplist header<span style="color:#f92672">(</span>zlbytes+zltail+zllen<span style="color:#f92672">)</span>大小，单位byte
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Size of the <span style="color:#e6db74">&#34;end of ziplist&#34;</span> entry. Just one byte. */
</span></span><span style="display:flex;"><span>//zlend大小，单位byte
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_END_SIZE        (sizeof(uint8_t))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the pointer to the first entry of a ziplist. */
</span></span><span style="display:flex;"><span>//第一个entry的首地址
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the pointer to the last entry of a ziplist, using the
</span></span><span style="display:flex;"><span> * last entry offset inside the ziplist header. */
</span></span><span style="display:flex;"><span>//intrev32ifbe的作用：
</span></span><span style="display:flex;"><span> //因为zltail字段采用littele endian表示，所以
</span></span><span style="display:flex;"><span> //1：如果为BYTE_ORDER<span style="color:#f92672">(</span>在little endian机器上编译代码<span style="color:#f92672">)</span>为little endian，则nothing.
</span></span><span style="display:flex;"><span> //2：如果BYTE_ORDER（在big endian机器上编译代码）为big endian,则将zltail field的值由little endian转换为big endian.
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the pointer to the last byte of a ziplist, which is, the
</span></span><span style="display:flex;"><span> * end of ziplist FF entry. */
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Increment the number of items field in the ziplist header. Note that this
</span></span><span style="display:flex;"><span> * macro should never overflow the unsigned <span style="color:#ae81ff">16</span> bit integer, since entires are
</span></span><span style="display:flex;"><span> * always pushed one at a time. When UINT16_MAX is reached we want the count
</span></span><span style="display:flex;"><span> * to stay there to signal that a full scan is needed to get the number of
</span></span><span style="display:flex;"><span> * items inside the ziplist. */
</span></span><span style="display:flex;"><span>//incr ziplist中entry的数量
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_INCR_LENGTH(zl,incr) { \</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ZIPLIST_LENGTH<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span> &lt; UINT16_MAX<span style="color:#f92672">)</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        ZIPLIST_LENGTH<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> intrev16ifbe<span style="color:#f92672">(</span>intrev16ifbe<span style="color:#f92672">(</span>ZIPLIST_LENGTH<span style="color:#f92672">(</span>zl<span style="color:#f92672">))</span>+incr<span style="color:#f92672">)</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* We use this <span style="color:#66d9ef">function</span> to receive information about a ziplist entry.
</span></span><span style="display:flex;"><span> * Note that this is not how the data is actually encoded, is just what we
</span></span><span style="display:flex;"><span> * get filled by a <span style="color:#66d9ef">function</span> in order to operate more easily. */
</span></span><span style="display:flex;"><span>typedef struct zlentry <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    //表示prelen字段的长度，1or5bytes
</span></span><span style="display:flex;"><span>    unsigned int prevrawlensize; /* Bytes used to encode the previos entry len*/
</span></span><span style="display:flex;"><span>    //用于表示prev entry的长度
</span></span><span style="display:flex;"><span>    unsigned int prevrawlen;     /* Previous entry len. */
</span></span><span style="display:flex;"><span>    //用于表示encoding字段的长度
</span></span><span style="display:flex;"><span>    unsigned int lensize;        /* Bytes used to encode this entry type/len.
</span></span><span style="display:flex;"><span>                                    For example strings have a 1, <span style="color:#ae81ff">2</span> or <span style="color:#ae81ff">5</span> bytes
</span></span><span style="display:flex;"><span>                                    header. Integers always use a single byte.*/
</span></span><span style="display:flex;"><span>    //content字段的长度
</span></span><span style="display:flex;"><span>    unsigned int len;            /* Bytes used to represent the actual entry.
</span></span><span style="display:flex;"><span>                                    For strings this is just the string length
</span></span><span style="display:flex;"><span>                                    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">for</span> integers it is 1, 2, 3, 4, <span style="color:#ae81ff">8</span> or
</span></span><span style="display:flex;"><span>                                    <span style="color:#ae81ff">0</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span> bit immediate<span style="color:#f92672">)</span> depending on the
</span></span><span style="display:flex;"><span>                                    number range. */
</span></span><span style="display:flex;"><span>    //prelen+encoding字段的长度
</span></span><span style="display:flex;"><span>    unsigned int headersize;     /* prevrawlensize + lensize. */
</span></span><span style="display:flex;"><span>    //表示是string编码还是integer编码，长度为固定值1bytes
</span></span><span style="display:flex;"><span>    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
</span></span><span style="display:flex;"><span>                                    the entry encoding. However <span style="color:#66d9ef">for</span> <span style="color:#ae81ff">4</span> bits
</span></span><span style="display:flex;"><span>                                    immediate integers this can assume a range
</span></span><span style="display:flex;"><span>                                    of values and must be range-checked. */
</span></span><span style="display:flex;"><span>    //用于指向当前entry的首地址
</span></span><span style="display:flex;"><span>    unsigned char *p;            /* Pointer to the very start of the entry, that
</span></span><span style="display:flex;"><span>                                    is, this points to prev-entry-len field. */
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span> zlentry;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//用于初始化zlentry结构体
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIPLIST_ENTRY_ZERO(zle) { \</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;prevrawlensize <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;prevrawlen <span style="color:#f92672">=</span> 0; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;lensize <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;len <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;headersize <span style="color:#f92672">=</span> 0; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;encoding <span style="color:#f92672">=</span> 0; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">(</span>zle<span style="color:#f92672">)</span>-&gt;p <span style="color:#f92672">=</span> NULL; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Extract the encoding from the byte pointed by <span style="color:#e6db74">&#39;ptr&#39;</span> and set it into
</span></span><span style="display:flex;"><span> * <span style="color:#e6db74">&#39;encoding&#39;</span> field of the zlentry structure. */
</span></span><span style="display:flex;"><span>//从ptr指向的内存中获取zlentry中的encoding字段,如果是integer则正好是1bytes，即ptr<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>//如果是string类型，需要将encoding中表示content的长度部分清0
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_ENTRY_ENCODING(ptr, encoding) do {  \</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">(</span>encoding<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ptr<span style="color:#f92672">[</span>0<span style="color:#f92672">])</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>encoding<span style="color:#f92672">)</span> &lt; ZIP_STR_MASK<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>encoding<span style="color:#f92672">)</span> &amp;<span style="color:#f92672">=</span> ZIP_STR_MASK; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return bytes needed to store integer encoded by <span style="color:#e6db74">&#39;encoding&#39;</span>. */
</span></span><span style="display:flex;"><span>//根据encoding，获取content的长度
</span></span><span style="display:flex;"><span>unsigned int zipIntSize<span style="color:#f92672">(</span>unsigned char encoding<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    switch<span style="color:#f92672">(</span>encoding<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ZIP_INT_8B:  <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ZIP_INT_16B: <span style="color:#66d9ef">return</span> 2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ZIP_INT_24B: <span style="color:#66d9ef">return</span> 3;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ZIP_INT_32B: <span style="color:#66d9ef">return</span> 4;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> ZIP_INT_64B: <span style="color:#66d9ef">return</span> 8;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>encoding &gt;<span style="color:#f92672">=</span> ZIP_INT_IMM_MIN <span style="color:#f92672">&amp;&amp;</span> encoding &lt;<span style="color:#f92672">=</span> ZIP_INT_IMM_MAX<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> 0; /* <span style="color:#ae81ff">4</span> bit immediate */
</span></span><span style="display:flex;"><span>    panic<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Invalid integer encoding 0x%02X&#34;</span>, encoding<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Write the encoidng header of the entry in <span style="color:#e6db74">&#39;p&#39;</span>. If p is NULL it just returns
</span></span><span style="display:flex;"><span> * the amount of bytes required to encode such a length. Arguments:
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * <span style="color:#e6db74">&#39;encoding&#39;</span> is the encoding we are using <span style="color:#66d9ef">for</span> the entry. It could be
</span></span><span style="display:flex;"><span> * ZIP_INT_* or ZIP_STR_* or between ZIP_INT_IMM_MIN and ZIP_INT_IMM_MAX
</span></span><span style="display:flex;"><span> * <span style="color:#66d9ef">for</span> single-byte small immediate integers.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * <span style="color:#e6db74">&#39;rawlen&#39;</span> is only used <span style="color:#66d9ef">for</span> ZIP_STR_* encodings and is the length of the
</span></span><span style="display:flex;"><span> * srting that this entry represents.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * The <span style="color:#66d9ef">function</span> returns the number of bytes used by the encoding/length
</span></span><span style="display:flex;"><span> * header stored in <span style="color:#e6db74">&#39;p&#39;</span>. */
</span></span><span style="display:flex;"><span>//根据参数encoding（只判断encoding的低位2bits）判断是string还是integer，
</span></span><span style="display:flex;"><span>//如果是string则将type/len进行拼接encoding，并保存在p指向的内存
</span></span><span style="display:flex;"><span>//如果是integer则将encoding 保存在p指向的内存
</span></span><span style="display:flex;"><span>//函数返回值位encoding字段的长度
</span></span><span style="display:flex;"><span>//rawlen 表示string的长度
</span></span><span style="display:flex;"><span>unsigned int zipStoreEntryEncoding<span style="color:#f92672">(</span>unsigned char *p, unsigned char encoding, unsigned int rawlen<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    unsigned char len <span style="color:#f92672">=</span> 1, buf<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ZIP_IS_STR<span style="color:#f92672">(</span>encoding<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        /* Although encoding is given it may not be set <span style="color:#66d9ef">for</span> strings,
</span></span><span style="display:flex;"><span>         * so we determine it here using the raw length. */
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rawlen &lt;<span style="color:#f92672">=</span> 0x3f<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!p<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> ZIP_STR_06B | rawlen;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>rawlen &lt;<span style="color:#f92672">=</span> 0x3fff<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            len <span style="color:#f92672">+=</span> 1;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!p<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> ZIP_STR_14B | <span style="color:#f92672">((</span>rawlen &gt;&gt; 8<span style="color:#f92672">)</span> &amp; 0x3f<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> rawlen &amp; 0xff;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            len <span style="color:#f92672">+=</span> 4;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!p<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> ZIP_STR_32B;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>1<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>rawlen &gt;&gt; 24<span style="color:#f92672">)</span> &amp; 0xff;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>rawlen &gt;&gt; 16<span style="color:#f92672">)</span> &amp; 0xff;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>rawlen &gt;&gt; 8<span style="color:#f92672">)</span> &amp; 0xff;
</span></span><span style="display:flex;"><span>            buf<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> rawlen &amp; 0xff;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        /* Implies integer encoding, so length is always 1. */
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!p<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span>        buf<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> encoding;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* Store this length at p. */
</span></span><span style="display:flex;"><span>    memcpy<span style="color:#f92672">(</span>p,buf,len<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Decode the entry encoding type and data length <span style="color:#f92672">(</span>string length <span style="color:#66d9ef">for</span> strings,
</span></span><span style="display:flex;"><span> * number of bytes used <span style="color:#66d9ef">for</span> the integer <span style="color:#66d9ef">for</span> integer entries<span style="color:#f92672">)</span> encoded in <span style="color:#e6db74">&#39;ptr&#39;</span>.
</span></span><span style="display:flex;"><span> * The <span style="color:#e6db74">&#39;encoding&#39;</span> variable will hold the entry encoding, the <span style="color:#e6db74">&#39;lensize&#39;</span>
</span></span><span style="display:flex;"><span> * variable will hold the number of bytes required to encode the entry
</span></span><span style="display:flex;"><span> * length, and the <span style="color:#e6db74">&#39;len&#39;</span> variable will hold the entry length. */
</span></span><span style="display:flex;"><span>//lensize表示encoding字段的长度
</span></span><span style="display:flex;"><span>//len表示content的长度
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_DECODE_LENGTH(ptr, encoding, lensize, len) do {                    \</span>
</span></span><span style="display:flex;"><span>    ZIP_ENTRY_ENCODING<span style="color:#f92672">((</span>ptr<span style="color:#f92672">)</span>, <span style="color:#f92672">(</span>encoding<span style="color:#f92672">))</span>;                                     <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>encoding<span style="color:#f92672">)</span> &lt; ZIP_STR_MASK<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                                           <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>encoding<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> ZIP_STR_06B<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                                       <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            <span style="color:#f92672">(</span>lensize<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 1;                                                     <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            <span style="color:#f92672">(</span>len<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ptr<span style="color:#f92672">)[</span>0<span style="color:#f92672">]</span> &amp; 0x3f;                                           <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>encoding<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> ZIP_STR_14B<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                                <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            <span style="color:#f92672">(</span>lensize<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 2;                                                     <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            <span style="color:#f92672">(</span>len<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(((</span>ptr<span style="color:#f92672">)[</span>0<span style="color:#f92672">]</span> &amp; 0x3f<span style="color:#f92672">)</span> <span style="color:#e6db74">&lt;&lt; 8) | (ptr)[1];                       \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else if ((encoding) == ZIP_STR_32B) {                                \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (lensize) = 5;                                                     \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (len) = ((ptr)[1] &lt;&lt; 24) |                                         \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    ((ptr)[2] &lt;&lt; 16) |                                         \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    ((ptr)[3] &lt;&lt;  8</span><span style="color:#f92672">)</span> |                                         <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>                    <span style="color:#f92672">((</span>ptr<span style="color:#f92672">)[</span>4<span style="color:#f92672">])</span>;                                                <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>                                                               <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            panic<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Invalid string encoding 0x%02X&#34;</span>, <span style="color:#f92672">(</span>encoding<span style="color:#f92672">))</span>;               <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">}</span>                                                                      <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>                                                                   <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">(</span>lensize<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 1;                                                         <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">(</span>len<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> zipIntSize<span style="color:#f92672">(</span>encoding<span style="color:#f92672">)</span>;                                          <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">}</span>                                                                          <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Encode the length of the previous entry and write it to <span style="color:#e6db74">&#34;p&#34;</span>. This only
</span></span><span style="display:flex;"><span> * uses the larger encoding <span style="color:#f92672">(</span>required in __ziplistCascadeUpdate<span style="color:#f92672">)</span>. */
</span></span><span style="display:flex;"><span>//prelen字段的长度为5bytes，将len存储到prelen字段
</span></span><span style="display:flex;"><span>int zipStorePrevEntryLengthLarge<span style="color:#f92672">(</span>unsigned char *p, unsigned int len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p !<span style="color:#f92672">=</span> NULL<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> ZIP_BIG_PREVLEN;
</span></span><span style="display:flex;"><span>        memcpy<span style="color:#f92672">(</span>p+1,&amp;len,sizeof<span style="color:#f92672">(</span>len<span style="color:#f92672">))</span>;
</span></span><span style="display:flex;"><span>        memrev32ifbe<span style="color:#f92672">(</span>p+1<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 1+sizeof<span style="color:#f92672">(</span>len<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Encode the length of the previous entry and write it to <span style="color:#e6db74">&#34;p&#34;</span>. Return the
</span></span><span style="display:flex;"><span> * number of bytes needed to encode this length <span style="color:#66d9ef">if</span> <span style="color:#e6db74">&#34;p&#34;</span> is NULL. */
</span></span><span style="display:flex;"><span>//获取entry的pre length field
</span></span><span style="display:flex;"><span>unsigned int zipStorePrevEntryLength<span style="color:#f92672">(</span>unsigned char *p, unsigned int len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">==</span> NULL<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>len &lt; ZIP_BIG_PREVLEN<span style="color:#f92672">)</span> ? <span style="color:#ae81ff">1</span> : sizeof<span style="color:#f92672">(</span>len<span style="color:#f92672">)</span>+1;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>len &lt; ZIP_BIG_PREVLEN<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> 1;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> zipStorePrevEntryLengthLarge<span style="color:#f92672">(</span>p,len<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the number of bytes used to encode the length of the previous
</span></span><span style="display:flex;"><span> * entry. The length is returned by setting the var <span style="color:#e6db74">&#39;prevlensize&#39;</span>. */
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>ptr<span style="color:#f92672">)[</span>0<span style="color:#f92672">]</span> &lt; ZIP_BIG_PREVLEN<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                                          <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">(</span>prevlensize<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 1;                                                     <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>                                                                   <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">(</span>prevlensize<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> 5;                                                     <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">}</span>                                                                          <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the length of the previous element, and the number of bytes that
</span></span><span style="display:flex;"><span> * are used in order to encode the previous element length.
</span></span><span style="display:flex;"><span> * <span style="color:#e6db74">&#39;ptr&#39;</span> must point to the prevlen prefix of an entry <span style="color:#f92672">(</span>that encodes the
</span></span><span style="display:flex;"><span> * length of the previos entry in order to navigate the elements backward<span style="color:#f92672">)</span>.
</span></span><span style="display:flex;"><span> * The length of the previous entry is stored in <span style="color:#e6db74">&#39;prevlen&#39;</span>, the number of
</span></span><span style="display:flex;"><span> * bytes needed to encode the previous entry length are stored in
</span></span><span style="display:flex;"><span> * <span style="color:#e6db74">&#39;prevlensize&#39;</span>. */
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \</span>
</span></span><span style="display:flex;"><span>    ZIP_DECODE_PREVLENSIZE<span style="color:#f92672">(</span>ptr, prevlensize<span style="color:#f92672">)</span>;                                  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>prevlensize<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                                                  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        <span style="color:#f92672">(</span>prevlen<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ptr<span style="color:#f92672">)[</span>0<span style="color:#f92672">]</span>;                                                  <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>prevlensize<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 5<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>                                           <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        assert<span style="color:#f92672">(</span>sizeof<span style="color:#f92672">((</span>prevlensize<span style="color:#f92672">))</span> <span style="color:#f92672">==</span> 4<span style="color:#f92672">)</span>;//assert<span style="color:#f92672">(</span>sizeof<span style="color:#f92672">(</span>prelen<span style="color:#f92672">)==</span>4<span style="color:#f92672">)</span>;????                                   <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        memcpy<span style="color:#f92672">(</span>&amp;<span style="color:#f92672">(</span>prevlen<span style="color:#f92672">)</span>, <span style="color:#f92672">((</span>char*<span style="color:#f92672">)(</span>ptr<span style="color:#f92672">))</span> + 1, 4<span style="color:#f92672">)</span>;                             <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>        memrev32ifbe<span style="color:#f92672">(</span>&amp;prevlen<span style="color:#f92672">)</span>;                                                <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    <span style="color:#f92672">}</span>                                                                          <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span><span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Given a pointer <span style="color:#e6db74">&#39;p&#39;</span> to the prevlen info that prefixes an entry, this
</span></span><span style="display:flex;"><span> * <span style="color:#66d9ef">function</span> returns the difference in number of bytes needed to encode
</span></span><span style="display:flex;"><span> * the prevlen <span style="color:#66d9ef">if</span> the previous entry changes of size.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * So <span style="color:#66d9ef">if</span> A is the number of bytes used right now to encode the <span style="color:#e6db74">&#39;prevlen&#39;</span>
</span></span><span style="display:flex;"><span> * field.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * And B is the number of bytes that are needed in order to encode the
</span></span><span style="display:flex;"><span> * <span style="color:#e6db74">&#39;prevlen&#39;</span> <span style="color:#66d9ef">if</span> the previous element will be updated to one of size <span style="color:#e6db74">&#39;len&#39;</span>.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * Then the <span style="color:#66d9ef">function</span> returns B - A
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * So the <span style="color:#66d9ef">function</span> returns a positive number <span style="color:#66d9ef">if</span> more space is needed,
</span></span><span style="display:flex;"><span> * a negative number <span style="color:#66d9ef">if</span> less space is needed, or zero <span style="color:#66d9ef">if</span> the same space
</span></span><span style="display:flex;"><span> * is needed. */
</span></span><span style="display:flex;"><span>//返回new prelensize - old prevlensize
</span></span><span style="display:flex;"><span>int zipPrevLenByteDiff<span style="color:#f92672">(</span>unsigned char *p, unsigned int len<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    unsigned int prevlensize;
</span></span><span style="display:flex;"><span>    ZIP_DECODE_PREVLENSIZE<span style="color:#f92672">(</span>p, prevlensize<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> zipStorePrevEntryLength<span style="color:#f92672">(</span>NULL, len<span style="color:#f92672">)</span> - prevlensize;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return the total number of bytes used by the entry pointed to by <span style="color:#e6db74">&#39;p&#39;</span>. */
</span></span><span style="display:flex;"><span>// 获取entry total length 
</span></span><span style="display:flex;"><span>unsigned int zipRawEntryLength<span style="color:#f92672">(</span>unsigned char *p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    unsigned int prevlensize, encoding, lensize, len;
</span></span><span style="display:flex;"><span>    ZIP_DECODE_PREVLENSIZE<span style="color:#f92672">(</span>p, prevlensize<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    ZIP_DECODE_LENGTH<span style="color:#f92672">(</span>p + prevlensize, encoding, lensize, len<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> prevlensize + lensize + len;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Check <span style="color:#66d9ef">if</span> string pointed to by <span style="color:#e6db74">&#39;entry&#39;</span> can be encoded as an integer.
</span></span><span style="display:flex;"><span> * Stores the integer value in <span style="color:#e6db74">&#39;v&#39;</span> and its encoding in <span style="color:#e6db74">&#39;encoding&#39;</span>. */
</span></span><span style="display:flex;"><span>int zipTryEncoding<span style="color:#f92672">(</span>unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    long long value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>entrylen &gt;<span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span> <span style="color:#f92672">||</span> entrylen <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>string2ll<span style="color:#f92672">((</span>char*<span style="color:#f92672">)</span>entry,entrylen,&amp;value<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        /* Great, the string can be encoded. Check what<span style="color:#e6db74">&#39;s the smallest
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         * of our encoding types that can hold this value. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//immediate 4 bits integer
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (value &gt;= 0 &amp;&amp; value &lt;= 12) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *encoding = ZIP_INT_IMM_MIN+value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else if (value &gt;= INT8_MIN &amp;&amp; value &lt;= INT8_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *encoding = ZIP_INT_8B;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else if (value &gt;= INT16_MIN &amp;&amp; value &lt;= INT16_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *encoding = ZIP_INT_16B;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else if (value &gt;= INT24_MIN &amp;&amp; value &lt;= INT24_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *encoding = ZIP_INT_24B;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else if (value &gt;= INT32_MIN &amp;&amp; value &lt;= INT32_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *encoding = ZIP_INT_32B;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *encoding = ZIP_INT_64B;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        *v = value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Store integer &#39;</span>value<span style="color:#e6db74">&#39; at &#39;</span>p<span style="color:#e6db74">&#39;, encoded as &#39;</span>encoding<span style="color:#e6db74">&#39; */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int16_t i16;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int32_t i32;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int64_t i64;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (encoding == ZIP_INT_8B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ((int8_t*)p)[0] = (int8_t)value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_16B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        i16 = value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(p,&amp;i16,sizeof(i16));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev16ifbe(p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_24B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        i32 = value&lt;&lt;8;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev32ifbe(&amp;i32);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(p,((uint8_t*)&amp;i32)+1,sizeof(i32)-sizeof(uint8_t));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_32B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        i32 = value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(p,&amp;i32,sizeof(i32));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev32ifbe(p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_64B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        i64 = value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(p,&amp;i64,sizeof(i64));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev64ifbe(p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Nothing to do, the value is stored in the encoding itself. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Read integer encoded as &#39;</span>encoding<span style="color:#e6db74">&#39; from &#39;</span>p<span style="color:#e6db74">&#39; */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">//获取int_*的content
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int16_t i16;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int32_t i32;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int64_t i64, ret = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (encoding == ZIP_INT_8B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ret = ((int8_t*)p)[0];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_16B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(&amp;i16,p,sizeof(i16));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev16ifbe(&amp;i16);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ret = i16;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_32B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(&amp;i32,p,sizeof(i32));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev32ifbe(&amp;i32);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ret = i32;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_24B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        i32 = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(((uint8_t*)&amp;i32)+1,p,sizeof(i32)-sizeof(uint8_t));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev32ifbe(&amp;i32);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ret = i32&gt;&gt;8;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding == ZIP_INT_64B) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(&amp;i64,p,sizeof(i64));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memrev64ifbe(&amp;i64);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ret = i64;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ret = (encoding &amp; ZIP_INT_IMM_MASK)-1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return ret;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Return a struct with all information about an entry. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">//根据p指向的内存，获取zlentry结构体
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">void zipEntry(unsigned char *p, zlentry *e) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //获取prevlensize（prelen字段的长度）和prelen字段
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIP_DECODE_PREVLEN(p, e-&gt;prevrawlensize, e-&gt;prevrawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //获取encoding,lensize(encodiing字段的长度)，和len(content的长度)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIP_DECODE_LENGTH(p + e-&gt;prevrawlensize, e-&gt;encoding, e-&gt;lensize, e-&gt;len);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //prevlen 和encoding字段的长度
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    e-&gt;headersize = e-&gt;prevrawlensize + e-&gt;lensize;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //指向当前entry的首地址
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    e-&gt;p = p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Create a new empty ziplist. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/*创建一个empty的ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">*
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">*   |-------|------------|-----|
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">*   |zlbytes|zltail|zllen|zlend|
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">*   |-------|------------|-----|
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">*
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">*/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistNew(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned int bytes = ZIPLIST_HEADER_SIZE+1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *zl = zmalloc(bytes);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_LENGTH(zl) = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl[bytes-1] = ZIP_END;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Resize the ziplist. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">//realloc ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = zrealloc(zl,len);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//total bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl[len-1] = ZIP_END;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* When an entry is inserted, we need to set the prevlen field of the next
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * entry to equal the length of the inserted entry. It can occur that this
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * length cannot be encoded in 1 byte and the next entry needs to be grow
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * because this only happens when an entry is already being inserted (which
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * causes a realloc and memmove). However, encoding the prevlen may require
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * that this entry is grown as well. This effect may cascade throughout
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * the ziplist when there are consecutive entries with a size close to
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * ZIP_BIG_PREVLEN, so we need to check that the prevlen can be encoded in
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * every consecutive entry.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Note that this effect can also happen in reverse, where the bytes required
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * to encode the prevlen field can shrink. This effect is deliberately ignored,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * because it can cause a &#34;flapping&#34; effect where a chain prevlen fields is
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * first grown and then shrunk again after consecutive inserts. Rather, the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * field is allowed to stay larger than necessary, because a large prevlen
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * field implies the ziplist is holding large entries anyway.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The pointer &#34;p&#34; points to the first entry that does NOT need to be
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * updated, i.e. consecutive fields MAY need an update. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">//连锁更新
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //curlen表示zl的total len
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t offset, noffset, extra;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *np;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zlentry cur, next;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //p[0]为first entry的首地址
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    while (p[0] != ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipEntry(p, &amp;cur);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//first entry的total length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        rawlen = cur.headersize + cur.len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//获取next entry的prevlen field的需要多少个bytes（1 or 5）来存储更新的first entry的total length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        rawlensize = zipStorePrevEntryLength(NULL,rawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Abort if there is no next entry. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//当前engry没有nextentry.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (p[rawlen] == ZIP_END) break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//获取next entry的zlentry结构体
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipEntry(p+rawlen, &amp;next);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Abort when &#34;prevlen&#34; has not changed. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (next.prevrawlen == rawlen) break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//next entry的prevlen字段需要expand
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (next.prevrawlensize &lt; rawlensize) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* The &#34;prevlen&#34; field of &#34;next&#34; needs more bytes to hold
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * the raw length of &#34;cur&#34;. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //first entry的首地址相对于zp首地址的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            offset = p-zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //next entry prevlen字段需要扩展的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            extra = rawlensize-next.prevrawlensize;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //realloc zp
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistResize(zl,curlen+extra);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //first entry的首地址
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = zl+offset;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Current pointer and offset for next element. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            //rawlen为first entry的total length , np means next entry的首地址
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    np = p+rawlen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //next entry相对于zp首地址的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            noffset = np-zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Update tail offset when next element is not the tail element. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //next entry非ziplist 的last entry
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                ZIPLIST_TAIL_OFFSET(zl) =
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Move the tail to the back. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            memmove(np+rawlensize,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                np+next.prevrawlensize,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                curlen-noffset-next.prevrawlensize-1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //存储next entry的prelen
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zipStorePrevEntryLength(np,rawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Advance the cursor */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p += rawlen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            curlen += extra;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (next.prevrawlensize &gt; rawlensize) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                /* This would result in shrinking, which we want to avoid.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                 * So, set &#34;rawlen&#34; in the available bytes. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                zipStorePrevEntryLength(p+rawlen,rawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Stop here, as the raw length of &#34;next&#34; has not changed. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Delete &#34;num&#34; entries, starting at &#34;p&#34;. Returns pointer to the ziplist. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">//删除num个entry
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned int i, totlen, deleted = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t offset;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int nextdiff = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zlentry first, tail;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zipEntry(p, &amp;first);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p += zipRawEntryLength(p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        deleted++;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (totlen &gt; 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//p not zlend
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (p[0] != ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Storing `prevrawlen` in this entry may increase or decrease the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * number of bytes required compare to the current `prevrawlen`.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * There always is room to store this, because it was previously
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * stored by an entry that is now being deleted. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //nextdiff = first prevlensize 减去 第num+1个entry的prevlensize的差值
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Note that there is always space when p jumps backward: if
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * the new previous entry is large, one of the deleted elements
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * had a 5 bytes prevlen header, so there is for sure at least
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * 5 bytes free and we need just 4. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p -= nextdiff;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	    //存储first entry前边的entry(即第0个entry)的length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zipStorePrevEntryLength(p,first.prevrawlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Update offset for tail */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ZIPLIST_TAIL_OFFSET(zl) =
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* When the tail contains more than one entry, we need to take
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * &#34;nextdiff&#34; in account as well. Otherwise, a change in the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">             * size of prevlen doesn&#39;</span>t have an effect on the *tail* offset. */
</span></span><span style="display:flex;"><span>            zipEntry<span style="color:#f92672">(</span>p, &amp;tail<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>tail.headersize+tail.len<span style="color:#f92672">]</span> !<span style="color:#f92672">=</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                ZIPLIST_TAIL_OFFSET<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                   intrev32ifbe<span style="color:#f92672">(</span>intrev32ifbe<span style="color:#f92672">(</span>ZIPLIST_TAIL_OFFSET<span style="color:#f92672">(</span>zl<span style="color:#f92672">))</span>+nextdiff<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            /* Move tail to the front of the ziplist */
</span></span><span style="display:flex;"><span>            memmove<span style="color:#f92672">(</span>first.p,p,
</span></span><span style="display:flex;"><span>                intrev32ifbe<span style="color:#f92672">(</span>ZIPLIST_BYTES<span style="color:#f92672">(</span>zl<span style="color:#f92672">))</span>-<span style="color:#f92672">(</span>p-zl<span style="color:#f92672">)</span>-1<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            /* The entire tail was deleted. No need to move memory. */
</span></span><span style="display:flex;"><span>	    //删除<span style="color:#f92672">[</span>first, last<span style="color:#f92672">]</span>entry之间的所有entry<span style="color:#f92672">(</span>包括last entry<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            ZIPLIST_TAIL_OFFSET<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                intrev32ifbe<span style="color:#f92672">((</span>first.p-zl<span style="color:#f92672">)</span>-first.prevrawlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        /* Resize and update length */
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> first.p-zl;
</span></span><span style="display:flex;"><span>        zl <span style="color:#f92672">=</span> ziplistResize<span style="color:#f92672">(</span>zl, intrev32ifbe<span style="color:#f92672">(</span>ZIPLIST_BYTES<span style="color:#f92672">(</span>zl<span style="color:#f92672">))</span>-totlen+nextdiff<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>	//更新engry数量
</span></span><span style="display:flex;"><span>        ZIPLIST_INCR_LENGTH<span style="color:#f92672">(</span>zl,-deleted<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> zl+offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        /* When nextdiff !<span style="color:#f92672">=</span> 0, the raw length of the next entry has changed, so
</span></span><span style="display:flex;"><span>         * we need to cascade the update throughout the ziplist */
</span></span><span style="display:flex;"><span>	//可能需要连锁更新
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>nextdiff !<span style="color:#f92672">=</span> 0<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            zl <span style="color:#f92672">=</span> __ziplistCascadeUpdate<span style="color:#f92672">(</span>zl,p<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> zl;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Insert item at <span style="color:#e6db74">&#34;p&#34;</span>. */
</span></span><span style="display:flex;"><span>unsigned char *__ziplistInsert<span style="color:#f92672">(</span>unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    size_t curlen <span style="color:#f92672">=</span> intrev32ifbe<span style="color:#f92672">(</span>ZIPLIST_BYTES<span style="color:#f92672">(</span>zl<span style="color:#f92672">))</span>, reqlen;
</span></span><span style="display:flex;"><span>    unsigned int prevlensize, prevlen <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    size_t offset;
</span></span><span style="display:flex;"><span>    int nextdiff <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    unsigned char encoding <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    long long value <span style="color:#f92672">=</span> 123456789; /* initialized to avoid warning. Using a value
</span></span><span style="display:flex;"><span>                                    that is easy to see <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">for</span> some reason
</span></span><span style="display:flex;"><span>                                    we use it uninitialized. */
</span></span><span style="display:flex;"><span>    zlentry tail;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* Find out prevlen <span style="color:#66d9ef">for</span> the entry that is inserted. */
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> !<span style="color:#f92672">=</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	//获得p指向entry的prelensize和前一个entry的total length
</span></span><span style="display:flex;"><span>        ZIP_DECODE_PREVLEN<span style="color:#f92672">(</span>p, prevlensize, prevlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>	//如果p指向zllend
</span></span><span style="display:flex;"><span>        unsigned char *ptail <span style="color:#f92672">=</span> ZIPLIST_ENTRY_TAIL<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ptail<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> !<span style="color:#f92672">=</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            prevlen <span style="color:#f92672">=</span> zipRawEntryLength<span style="color:#f92672">(</span>ptail<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* See <span style="color:#66d9ef">if</span> the entry can be encoded */
</span></span><span style="display:flex;"><span>    //reqlen为entry content的长度
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>zipTryEncoding<span style="color:#f92672">(</span>s,slen,&amp;value,&amp;encoding<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        /* <span style="color:#e6db74">&#39;encoding&#39;</span> is set to the appropriate integer encoding */
</span></span><span style="display:flex;"><span>	//integer的content长度
</span></span><span style="display:flex;"><span>        reqlen <span style="color:#f92672">=</span> zipIntSize<span style="color:#f92672">(</span>encoding<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        /* <span style="color:#e6db74">&#39;encoding&#39;</span> is untouched, however zipStoreEntryEncoding will use the
</span></span><span style="display:flex;"><span>         * string length to figure out how to encode it. */
</span></span><span style="display:flex;"><span>        //string ,slen为string的长度
</span></span><span style="display:flex;"><span>	reqlen <span style="color:#f92672">=</span> slen;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    /* We need space <span style="color:#66d9ef">for</span> both the length of the previous entry and
</span></span><span style="display:flex;"><span>     * the length of the payload. */
</span></span><span style="display:flex;"><span>    //获取prevlensize
</span></span><span style="display:flex;"><span>    reqlen <span style="color:#f92672">+=</span> zipStorePrevEntryLength<span style="color:#f92672">(</span>NULL,prevlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    //获取entry的encoding字段长度
</span></span><span style="display:flex;"><span>    reqlen <span style="color:#f92672">+=</span> zipStoreEntryEncoding<span style="color:#f92672">(</span>NULL,encoding,slen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* When the insert position is not equal to the tail, we need to
</span></span><span style="display:flex;"><span>     * make sure that the next entry can hold this entry<span style="color:#e6db74">&#39;s length in
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * its prevlen field. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int forcelarge = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //ziplist的total length不能变小
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (nextdiff == -4 &amp;&amp; reqlen &lt; 4) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        nextdiff = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        forcelarge = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Store offset because a realloc may change the address of zl. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    offset = p-zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p = zl+offset;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Apply memory move when necessary and update tail offset. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (p[0] != ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Subtract one because of the ZIP_END bytes */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Encode this entry&#39;</span>s raw length in the next entry. */
</span></span><span style="display:flex;"><span>	//forcelarge<span style="color:#f92672">==</span>1强制采用5bytes存储prevlen field
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>forcelarge<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>            zipStorePrevEntryLengthLarge<span style="color:#f92672">(</span>p+reqlen,reqlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            zipStorePrevEntryLength<span style="color:#f92672">(</span>p+reqlen,reqlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        /* Update offset <span style="color:#66d9ef">for</span> tail */
</span></span><span style="display:flex;"><span>        ZIPLIST_TAIL_OFFSET<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            intrev32ifbe<span style="color:#f92672">(</span>intrev32ifbe<span style="color:#f92672">(</span>ZIPLIST_TAIL_OFFSET<span style="color:#f92672">(</span>zl<span style="color:#f92672">))</span>+reqlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        /* When the tail contains more than one entry, we need to take
</span></span><span style="display:flex;"><span>         * <span style="color:#e6db74">&#34;nextdiff&#34;</span> in account as well. Otherwise, a change in the
</span></span><span style="display:flex;"><span>         * size of prevlen doesn<span style="color:#e6db74">&#39;t have an effect on the *tail* offset. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipEntry(p+reqlen, &amp;tail);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ZIPLIST_TAIL_OFFSET(zl) =
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* This element will be the new tail. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* When nextdiff != 0, the raw length of the next entry has changed, so
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * we need to cascade the update throughout the ziplist */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (nextdiff != 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        offset = p-zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = __ziplistCascadeUpdate(zl,p+reqlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = zl+offset;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Write the entry */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p += zipStorePrevEntryLength(p,prevlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p += zipStoreEntryEncoding(p,encoding,slen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (ZIP_IS_STR(encoding)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(p,s,slen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipSaveInteger(p,value,encoding);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_INCR_LENGTH(zl,1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Merge ziplists &#39;</span>first<span style="color:#e6db74">&#39; and &#39;</span>second<span style="color:#e6db74">&#39; by appending &#39;</span>second<span style="color:#e6db74">&#39; to &#39;</span>first<span style="color:#e6db74">&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * NOTE: The larger ziplist is reallocated to contain the new merged ziplist.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Either &#39;</span>first<span style="color:#e6db74">&#39; or &#39;</span>second<span style="color:#e6db74">&#39; can be used for the result.  The parameter not
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * used will be free&#39;</span>d and set to NULL.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * After calling this <span style="color:#66d9ef">function</span>, the input parameters are no longer valid since
</span></span><span style="display:flex;"><span> * they are changed and free<span style="color:#e6db74">&#39;d in-place.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * The result ziplist is the contents of &#39;</span>first<span style="color:#e6db74">&#39; followed by &#39;</span>second<span style="color:#e6db74">&#39;.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * On failure: returns NULL if the merge is impossible.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * On success: returns the merged ziplist (which is expanded version of either
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * &#39;</span>first<span style="color:#e6db74">&#39; or &#39;</span>second<span style="color:#e6db74">&#39;, also frees the other unused input ziplist, and sets the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * input ziplist argument equal to newly reallocated ziplist return value. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* If any params are null, we can&#39;</span>t merge, so NULL. */
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>first <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> *first <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> second <span style="color:#f92672">==</span> NULL <span style="color:#f92672">||</span> *second <span style="color:#f92672">==</span> NULL<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* Can<span style="color:#e6db74">&#39;t merge same list into itself. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //如果*first指向的ziplist和*second指向的ziplist相同
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (*first == *second)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //zl total bytes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //zl totol entry number
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int append;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *source, *target;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t target_bytes, source_bytes;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Pick the largest ziplist so we can resize easily in-place.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * We must also track if we are now appending or prepending to
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * the target ziplist. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (first_len &gt;= second_len) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* retain first, append second to first. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        target = *first;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        target_bytes = first_bytes;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        source = *second;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        source_bytes = second_bytes;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        //appending *seond指向的zl追加到*first指向的entry后边
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	append = 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* else, retain second, prepend first to second. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        target = *second;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        target_bytes = second_bytes;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        source = *first;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        source_bytes = first_bytes;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//prepanding *first指向的zl prepend到*second指向的zl前边
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        append = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Calculate final bytes (subtract one pair of metadata) */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //两个zl merged后的total length
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t zlbytes = first_bytes + second_bytes -
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                     ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //两个zl merged后的total entry number
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t zllength = first_len + second_len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Combined zl length should be limited within UINT16_MAX */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zllength = zllength &lt; UINT16_MAX ? zllength : UINT16_MAX;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Save offset positions before we start ripping memory apart. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    //last entry offset
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Extend target to new zlbytes then append or prepend source. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    target = zrealloc(target, zlbytes);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (append) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* append == appending to target */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Copy source after target (copying over original [END]):
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         *   [TARGET - END, SOURCE - HEADER] */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//将*second指向的zl追加到*first指向的zl后边
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(target + target_bytes - ZIPLIST_END_SIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">               source + ZIPLIST_HEADER_SIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">               source_bytes - ZIPLIST_HEADER_SIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* !append == prepending to target */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Move target *contents* exactly size of (source - [END]),
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         * then copy source into vacataed space (source - [END]):
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">         *   [SOURCE - END, TARGET - HEADER] */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	//将*first指向的zl添加到*second指向的zl前边
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memmove(target + source_bytes - ZIPLIST_END_SIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                target + ZIPLIST_HEADER_SIZE,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                target_bytes - ZIPLIST_HEADER_SIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Update header metadata. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* New tail offset is:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     *   + N bytes of first ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     *   - 1 byte for [END] of first ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     *   + M bytes for the offset of the original tail of the second ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     *   - J bytes for HEADER because second_offset keeps no header. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                                   (first_bytes - ZIPLIST_END_SIZE) +
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                                   (second_offset - ZIPLIST_HEADER_SIZE));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* __ziplistCascadeUpdate just fixes the prev length values until it finds a
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * correct prev length value (then it assumes the rest of the list is okay).
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * We tell CascadeUpdate to start at the first ziplist&#39;</span>s tail element to fix
</span></span><span style="display:flex;"><span>     * the merge seam. */
</span></span><span style="display:flex;"><span>    target <span style="color:#f92672">=</span> __ziplistCascadeUpdate<span style="color:#f92672">(</span>target, target+first_offset<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* Now free and NULL out what we didn<span style="color:#e6db74">&#39;t realloc */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (append) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(*second);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        *second = NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        *first = target;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(*first);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        *first = NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        *second = target;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return target;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return __ziplistInsert(zl,p,s,slen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Returns an offset to use for iterating with ziplistNext. When the given
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * index is negative, the list is traversed back to front. When the list
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * doesn&#39;</span>t contain an element at the provided index, NULL is returned. */
</span></span><span style="display:flex;"><span>unsigned char *ziplistIndex<span style="color:#f92672">(</span>unsigned char *zl, int index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    unsigned char *p;
</span></span><span style="display:flex;"><span>    unsigned int prevlensize, prevlen <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index &lt; 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>-index<span style="color:#f92672">)</span>-1;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> ZIPLIST_ENTRY_TAIL<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> !<span style="color:#f92672">=</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            ZIP_DECODE_PREVLEN<span style="color:#f92672">(</span>p, prevlensize, prevlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>prevlen &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> index--<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                p -<span style="color:#f92672">=</span> prevlen;
</span></span><span style="display:flex;"><span>                ZIP_DECODE_PREVLEN<span style="color:#f92672">(</span>p, prevlensize, prevlen<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> ZIPLIST_ENTRY_HEAD<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> !<span style="color:#f92672">=</span> ZIP_END <span style="color:#f92672">&amp;&amp;</span> index--<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">+=</span> zipRawEntryLength<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> ZIP_END <span style="color:#f92672">||</span> index &gt; 0<span style="color:#f92672">)</span> ? NULL : p;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return pointer to next entry in ziplist.
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * zl is the pointer to the ziplist
</span></span><span style="display:flex;"><span> * p is the pointer to the current element
</span></span><span style="display:flex;"><span> *
</span></span><span style="display:flex;"><span> * The element after <span style="color:#e6db74">&#39;p&#39;</span> is returned, otherwise NULL <span style="color:#66d9ef">if</span> we are at the end. */
</span></span><span style="display:flex;"><span>unsigned char *ziplistNext<span style="color:#f92672">(</span>unsigned char *zl, unsigned char *p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">((</span>void<span style="color:#f92672">)</span> zl<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* <span style="color:#e6db74">&#34;p&#34;</span> could be equal to ZIP_END, caused by ziplistDelete,
</span></span><span style="display:flex;"><span>     * and we should <span style="color:#66d9ef">return</span> NULL. Otherwise, we should <span style="color:#66d9ef">return</span> NULL
</span></span><span style="display:flex;"><span>     * when the *next* element is ZIP_END <span style="color:#f92672">(</span>there is no next entry<span style="color:#f92672">)</span>. */
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">+=</span> zipRawEntryLength<span style="color:#f92672">(</span>p<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Return pointer to previous entry in ziplist. */
</span></span><span style="display:flex;"><span>unsigned char *ziplistPrev<span style="color:#f92672">(</span>unsigned char *zl, unsigned char *p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    unsigned int prevlensize, prevlen <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    /* Iterating backwards from ZIP_END should <span style="color:#66d9ef">return</span> the tail. When <span style="color:#e6db74">&#34;p&#34;</span> is
</span></span><span style="display:flex;"><span>     * equal to the first element of the list, we<span style="color:#e6db74">&#39;re already at the head,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * and should return NULL. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (p[0] == ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ZIPLIST_ENTRY_TAIL(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return (p[0] == ZIP_END) ? NULL : p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(prevlen &gt; 0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return p-prevlen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Get entry pointed to by &#39;</span>p<span style="color:#e6db74">&#39; and store in either &#39;</span>*sstr<span style="color:#e6db74">&#39; or &#39;</span>sval<span style="color:#e6db74">&#39; depending
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * on the encoding of the entry. &#39;</span>*sstr<span style="color:#e6db74">&#39; is always set to NULL to be able
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * to find out whether the string pointer or the integer value was set.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Return 0 if &#39;</span>p<span style="color:#e6db74">&#39; points to the end of the ziplist, 1 otherwise. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zlentry entry;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (p == NULL || p[0] == ZIP_END) return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (sstr) *sstr = NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zipEntry(p, &amp;entry);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (ZIP_IS_STR(entry.encoding)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (sstr) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *slen = entry.len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *sstr = p+entry.headersize;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (sval) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Insert an entry at &#34;p&#34;. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return __ziplistInsert(zl,p,s,slen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Delete a single entry from the ziplist, pointed to by *p.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * Also update *p in place, to be able to iterate over the
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> * ziplist, while deleting entries. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    size_t offset = *p-zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = __ziplistDelete(zl,*p,1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* Store pointer to current element in p, because ziplistDelete will
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * do a realloc which might result in a different &#34;zl&#34;-pointer.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * When the delete direction is back to front, we might delete the last
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">     * entry and end up with &#34;p&#34; pointing to ZIP_END, so check this. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    *p = zl+offset;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Delete a range of entries from the ziplist. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *p = ziplistIndex(zl,index);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Compare entry pointer to by &#39;</span>p<span style="color:#e6db74">&#39; with &#39;</span>sstr<span style="color:#e6db74">&#39; of length &#39;</span>slen<span style="color:#e6db74">&#39;. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Return 1 if equal. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zlentry entry;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char sencoding;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    long long zval, sval;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (p[0] == ZIP_END) return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zipEntry(p, &amp;entry);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (ZIP_IS_STR(entry.encoding)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Raw compare */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (entry.len == slen) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return memcmp(p+entry.headersize,sstr,slen) == 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Try to compare encoded values. Don&#39;</span>t compare encoding because
</span></span><span style="display:flex;"><span>         * different implementations may encoded integers differently. */
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>zipTryEncoding<span style="color:#f92672">(</span>sstr,slen,&amp;sval,&amp;sencoding<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          zval <span style="color:#f92672">=</span> zipLoadInteger<span style="color:#f92672">(</span>p+entry.headersize,entry.encoding<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">return</span> zval <span style="color:#f92672">==</span> sval;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/* Find pointer to the entry equal to the specified entry. Skip <span style="color:#e6db74">&#39;skip&#39;</span> entries
</span></span><span style="display:flex;"><span> * between every comparison. Returns NULL when the field could not be found. */
</span></span><span style="display:flex;"><span>unsigned char *ziplistFind<span style="color:#f92672">(</span>unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    int skipcnt <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    unsigned char vencoding <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    long long vll <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>p<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> !<span style="color:#f92672">=</span> ZIP_END<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        unsigned int prevlensize, encoding, lensize, len;
</span></span><span style="display:flex;"><span>        unsigned char *q;
</span></span><span style="display:flex;"><span>	//获取p指向的entry的prevlensize
</span></span><span style="display:flex;"><span>        ZIP_DECODE_PREVLENSIZE<span style="color:#f92672">(</span>p, prevlensize<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>	//获取p指向entry的encoding的长度lensize，和content的长度len
</span></span><span style="display:flex;"><span>        ZIP_DECODE_LENGTH<span style="color:#f92672">(</span>p + prevlensize, encoding, lensize, len<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>	//q指向entry的content
</span></span><span style="display:flex;"><span>        q <span style="color:#f92672">=</span> p + prevlensize + lensize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>skipcnt <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>            /* Compare current entry with specified entry */
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>ZIP_IS_STR<span style="color:#f92672">(</span>encoding<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>len <span style="color:#f92672">==</span> vlen <span style="color:#f92672">&amp;&amp;</span> memcmp<span style="color:#f92672">(</span>q, vstr, vlen<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                /* Find out <span style="color:#66d9ef">if</span> the searched field can be encoded. Note that
</span></span><span style="display:flex;"><span>                 * we <span style="color:#66d9ef">do</span> it only the first time, once <span style="color:#66d9ef">done</span> vencoding is set
</span></span><span style="display:flex;"><span>                 * to non-zero and vll is set to the integer value. */
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>vencoding <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>!zipTryEncoding<span style="color:#f92672">(</span>vstr, vlen, &amp;vll, &amp;vencoding<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                        /* If the entry can<span style="color:#e6db74">&#39;t be encoded we set it to
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                         * UCHAR_MAX so that we don&#39;</span>t retry again the next
</span></span><span style="display:flex;"><span>                         * time. */
</span></span><span style="display:flex;"><span>                        vencoding <span style="color:#f92672">=</span> UCHAR_MAX;
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                    /* Must be non-zero by now */
</span></span><span style="display:flex;"><span>                    assert<span style="color:#f92672">(</span>vencoding<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                /* Compare current entry with specified entry, <span style="color:#66d9ef">do</span> it only
</span></span><span style="display:flex;"><span>                 * <span style="color:#66d9ef">if</span> vencoding !<span style="color:#f92672">=</span> UCHAR_MAX because <span style="color:#66d9ef">if</span> there is no encoding
</span></span><span style="display:flex;"><span>                 * possible <span style="color:#66d9ef">for</span> the field it can<span style="color:#e6db74">&#39;t be a valid integer. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (vencoding != UCHAR_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    long long ll = zipLoadInteger(q, encoding);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    if (ll == vll) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        return p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Reset skip count */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            skipcnt = skip;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Skip entry */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            skipcnt--;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Move to next entry */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = q + len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Return length of ziplist. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">unsigned int ziplistLen(unsigned char *zl) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned int len = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        len = intrev16ifbe(ZIPLIST_LENGTH(zl));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (*p != ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p += zipRawEntryLength(p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            len++;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Re-store length if small enough */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (len &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">/* Return ziplist blob size in bytes. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">size_t ziplistBlobLen(unsigned char *zl) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return intrev32ifbe(ZIPLIST_BYTES(zl));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">void ziplistRepr(unsigned char *zl) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int index = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zlentry entry;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;{total bytes %d} &#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;{num entries %u}\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;{tail offset %u}\n&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        intrev32ifbe(ZIPLIST_BYTES(zl)),
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        intrev16ifbe(ZIPLIST_LENGTH(zl)),
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p = ZIPLIST_ENTRY_HEAD(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    while(*p != ZIP_END) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipEntry(p, &amp;entry);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            &#34;{\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\taddr 0x%08lx,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\tindex %2d,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\toffset %5ld,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\thdr+entry len: %5u,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\thdr len%2u,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\tprevrawlen: %5u,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\tprevrawlensize: %2u,\n&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                &#34;\tpayload %5u\n&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (long unsigned)p,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            index,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (unsigned long) (p-zl),
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            entry.headersize+entry.len,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            entry.headersize,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            entry.prevrawlen,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            entry.prevrawlensize,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            entry.len);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\tbytes: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (unsigned int i = 0; i &lt; entry.headersize+entry.len; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;%02x|&#34;,p[i]);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p += entry.headersize;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ZIP_IS_STR(entry.encoding)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\t[str]&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry.len &gt; 40) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (fwrite(p,40,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;...&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (entry.len &amp;&amp;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    fwrite(p,entry.len,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\t[int]%lld&#34;, (long long) zipLoadInteger(p,entry.encoding));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n}\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p += entry.len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        index++;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;{end}\n\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#ifdef REDIS_TEST
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#include &lt;sys/time.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#include &#34;adlist.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#include &#34;sds.h&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">#define debug(f, ...) { if (DEBUG) printf(f, __VA_ARGS__); }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static unsigned char *createList() {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)&#34;foo&#34;, 3, ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)&#34;quux&#34;, 4, ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)&#34;hello&#34;, 5, ZIPLIST_HEAD);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)&#34;1024&#34;, 4, ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static unsigned char *createIntList() {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    char buf[32];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sprintf(buf, &#34;100&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sprintf(buf, &#34;128000&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sprintf(buf, &#34;-100&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sprintf(buf, &#34;4294967296&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_HEAD);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sprintf(buf, &#34;non integer&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    sprintf(buf, &#34;much much longer non integer&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = ziplistPush(zl, (unsigned char*)buf, strlen(buf), ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static long long usec(void) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    struct timeval tv;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    gettimeofday(&amp;tv,NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return (((long long)tv.tv_sec)*1000000)+tv.tv_usec;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static void stress(int pos, int num, int maxsize, int dnum) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int i,j,k;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *zl;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    char posstr[2][5] = { &#34;HEAD&#34;, &#34;TAIL&#34; };
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    long long start;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    for (i = 0; i &lt; maxsize; i+=dnum) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (j = 0; j &lt; i; j++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistPush(zl,(unsigned char*)&#34;quux&#34;,4,ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Do num times a push+pop from pos */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        start = usec();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (k = 0; k &lt; num; k++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistPush(zl,(unsigned char*)&#34;quux&#34;,4,pos);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistDeleteRange(zl,0,1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            i,intrev32ifbe(ZIPLIST_BYTES(zl)),num,posstr[pos],usec()-start);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static unsigned char *pop(unsigned char *zl, int where) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *p, *vstr;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned int vlen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    long long vlong;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    p = ziplistIndex(zl,where == ZIPLIST_HEAD ? 0 : -1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (where == ZIPLIST_HEAD)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Pop head: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        else
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Pop tail: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (vstr) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (vlen &amp;&amp; fwrite(vstr,vlen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;%lld&#34;, vlong);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        return ziplistDelete(zl,&amp;p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;ERROR: Could not pop\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        exit(1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static int randstring(char *target, unsigned int min, unsigned int max) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int p = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int len = min+rand()%(max-min+1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int minval, maxval;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    switch(rand() % 3) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    case 0:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        minval = 0;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        maxval = 255;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    case 1:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        minval = 48;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        maxval = 122;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    case 2:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        minval = 48;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        maxval = 52;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    default:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    while(p &lt; len)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        target[p++] = minval+rand()%(maxval-minval+1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    return len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">static void verify(unsigned char *zl, zlentry *e) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    int len = ziplistLen(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zlentry _e;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ZIPLIST_ENTRY_ZERO(&amp;_e);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    for (int i = 0; i &lt; len; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memset(&amp;e[i], 0, sizeof(zlentry));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipEntry(ziplistIndex(zl, i), &amp;e[i]);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memset(&amp;_e, 0, sizeof(zlentry));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zipEntry(ziplistIndex(zl, -len+i), &amp;_e);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(memcmp(&amp;e[i], &amp;_e, sizeof(zlentry)) == 0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">int ziplistTest(int argc, char **argv) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *zl, *p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned char *entry;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    unsigned int elen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    long long value;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    /* If an argument is given, use it as the random seed. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    if (argc == 2)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        srand(atoi(argv[1]));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = createIntList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = pop(zl,ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = pop(zl,ZIPLIST_HEAD);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = pop(zl,ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zl = pop(zl,ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Get element at index 3:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, 3);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Could not access index 3\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;%lld\n&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Get element at index 4 (out of range):\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, 4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (p == NULL) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;No entry\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Out of range index should return NULL, returned offset: %ld\n&#34;, p-zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Get element at index -1 (last element):\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, -1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Could not access index -1\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;%lld\n&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Get element at index -4 (first element):\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, -4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Could not access index -4\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;%lld\n&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Get element at index -5 (reverse out of range):\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, -5);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (p == NULL) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;No entry\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Out of range index should return NULL, returned offset: %ld\n&#34;, p-zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Iterate list from 0 to end:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, 0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Entry: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;%lld&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistNext(zl,p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Iterate list from 1 to end:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Entry: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;%lld&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistNext(zl,p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Iterate list from 2 to end:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, 2);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Entry: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;%lld&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistNext(zl,p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Iterate starting out of range:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, 4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;No entry\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Iterate from back to front:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, -1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Entry: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;%lld&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistPrev(zl,p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Iterate from back to front, deleting all items:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl, -1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (ziplistGet(p, &amp;entry, &amp;elen, &amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;Entry: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0) perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;%lld&#34;, value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistDelete(zl,&amp;p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistPrev(zl,p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Delete inclusive range 0,0:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistDeleteRange(zl, 0, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Delete inclusive range 0,1:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistDeleteRange(zl, 0, 2);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Delete inclusive range 1,2:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistDeleteRange(zl, 1, 2);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Delete with start index out of range:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistDeleteRange(zl, 5, 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Delete with num overflow:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistDeleteRange(zl, 1, 5);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Delete foo while iterating:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl,0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        while (ziplistGet(p,&amp;entry,&amp;elen,&amp;value)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            if (entry &amp;&amp; strncmp(&#34;foo&#34;,(char*)entry,elen) == 0) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;Delete foo\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                zl = ziplistDelete(zl,&amp;p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;Entry: &#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (entry) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    if (elen &amp;&amp; fwrite(entry,elen,1,stdout) == 0)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        perror(&#34;fwrite&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    printf(&#34;%lld&#34;,value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                p = ziplistNext(zl,p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Regression test for &gt;255 byte strings:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        char v1[257] = {0}, v2[257] = {0};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memset(v1,&#39;</span>x<span style="color:#e6db74">&#39;,256);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        memset(v2,&#39;</span>y<span style="color:#e6db74">&#39;,256);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistPush(zl,(unsigned char*)v1,strlen(v1),ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistPush(zl,(unsigned char*)v2,strlen(v2),ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Pop values again and compare their value. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl,0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(ziplistGet(p,&amp;entry,&amp;elen,&amp;value));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(strncmp(v1,(char*)entry,elen) == 0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl,1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(ziplistGet(p,&amp;entry,&amp;elen,&amp;value));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(strncmp(v2,(char*)entry,elen) == 0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;SUCCESS\n\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Regression test deleting next to last entries:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        char v[3][257] = {{0}};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zlentry e[3] = {{.prevrawlensize = 0, .prevrawlen = 0, .lensize = 0,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                         .len = 0, .headersize = 0, .encoding = 0, .p = NULL}};
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        size_t i;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (i = 0; i &lt; (sizeof(v)/sizeof(v[0])); i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            memset(v[i], &#39;</span>a<span style="color:#e6db74">&#39; + i, sizeof(v[0]));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        v[0][256] = &#39;</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        v[1][  1] = &#39;</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        v[2][256] = &#39;</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#39;;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (i = 0; i &lt; (sizeof(v)/sizeof(v[0])); i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistPush(zl, (unsigned char *) v[i], strlen(v[i]), ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        verify(zl, e);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(e[0].prevrawlensize == 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(e[1].prevrawlensize == 5);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(e[2].prevrawlensize == 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Deleting entry 1 will increase `prevrawlensize` for entry 2 */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *p = e[1].p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistDelete(zl, &amp;p);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        verify(zl, e);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(e[0].prevrawlensize == 1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        assert(e[1].prevrawlensize == 5);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;SUCCESS\n\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Create long list and check indices:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        char buf[32];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        int i,len;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (i = 0; i &lt; 1000; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            len = sprintf(buf,&#34;%d&#34;,i);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistPush(zl,(unsigned char*)buf,len,ZIPLIST_TAIL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (i = 0; i &lt; 1000; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistIndex(zl,i);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            assert(ziplistGet(p,NULL,NULL,&amp;value));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            assert(i == value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            p = ziplistIndex(zl,-i-1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            assert(ziplistGet(p,NULL,NULL,&amp;value));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            assert(999-i == value);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;SUCCESS\n\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Compare strings with ziplist entries:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl,0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistCompare(p,(unsigned char*)&#34;hello&#34;,5)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: not \&#34;hello\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistCompare(p,(unsigned char*)&#34;hella&#34;,5)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: \&#34;hella\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl,3);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistCompare(p,(unsigned char*)&#34;1024&#34;,4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: not \&#34;1024\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistCompare(p,(unsigned char*)&#34;1025&#34;,4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: \&#34;1025\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;SUCCESS\n\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Merge test:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* create list gives us: [hello, foo, quux, 1024] */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *zl2 = createList();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *zl3 = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *zl4 = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistMerge(&amp;zl4, &amp;zl4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Allowed merging of one ziplist into itself.\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Merge two empty ziplists, get empty result back. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl4 = ziplistMerge(&amp;zl3, &amp;zl4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistLen(zl4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Merging two empty ziplists created entries.\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zl2 = ziplistMerge(&amp;zl, &amp;zl2);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* merge gives us: [hello, foo, quux, 1024, hello, foo, quux, 1024] */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ziplistRepr(zl2);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistLen(zl2) != 8) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: Merged length not 8, but: %u\n&#34;, ziplistLen(zl2));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl2,0);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistCompare(p,(unsigned char*)&#34;hello&#34;,5)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: not \&#34;hello\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistCompare(p,(unsigned char*)&#34;hella&#34;,5)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: \&#34;hella\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl2,3);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistCompare(p,(unsigned char*)&#34;1024&#34;,4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: not \&#34;1024\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistCompare(p,(unsigned char*)&#34;1025&#34;,4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: \&#34;1025\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl2,4);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistCompare(p,(unsigned char*)&#34;hello&#34;,5)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: not \&#34;hello\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistCompare(p,(unsigned char*)&#34;hella&#34;,5)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: \&#34;hella\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        p = ziplistIndex(zl2,7);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (!ziplistCompare(p,(unsigned char*)&#34;1024&#34;,4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: not \&#34;1024\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        if (ziplistCompare(p,(unsigned char*)&#34;1025&#34;,4)) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            printf(&#34;ERROR: \&#34;1025\&#34;\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            return 1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        printf(&#34;SUCCESS\n\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        zfree(zl);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    printf(&#34;Stress with random payloads of different encoding:\n&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        int i,j,len,where;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *p;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        char buf[1024];
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        int buflen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        list *ref;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        listNode *refnode;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        /* Hold temp vars from ziplist */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned char *sstr;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        unsigned int slen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        long long sval;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        for (i = 0; i &lt; 20000; i++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            zl = ziplistNew();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            ref = listCreate();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            listSetFreeMethod(ref,(void (*)(void*))sdsfree);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            len = rand() % 256;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            /* Create lists */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            for (j = 0; j &lt; len; j++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                where = (rand() &amp; 1) ? ZIPLIST_HEAD : ZIPLIST_TAIL;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (rand() % 2) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    buflen = randstring(buf,1,sizeof(buf)-1);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    switch(rand() % 3) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    case 0:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        buflen = sprintf(buf,&#34;%lld&#34;,(0LL + rand()) &gt;&gt; 20);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    case 1:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        buflen = sprintf(buf,&#34;%lld&#34;,(0LL + rand()));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    case 2:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        buflen = sprintf(buf,&#34;%lld&#34;,(0LL + rand()) &lt;&lt; 20);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        break;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    default:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                        assert(NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                /* Add to ziplist */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                zl = ziplistPush(zl, (unsigned char*)buf, buflen, where);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                /* Add to reference list */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (where == ZIPLIST_HEAD) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    listAddNodeHead(ref,sdsnewlen(buf, buflen));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                } else if (where == ZIPLIST_TAIL) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    listAddNodeTail(ref,sdsnewlen(buf, buflen));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    assert(NULL);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            assert(listLength(ref) == ziplistLen(zl));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            for (j = 0; j &lt; len; j++) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                /* Naive way to get elements, but similar to the stresser
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                 * executed from the Tcl test suite. */
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                p = ziplistIndex(zl,j);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                refnode = listIndex(ref,j);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                assert(ziplistGet(p,&amp;sstr,&amp;slen,&amp;sval));
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                if (sstr == NULL) {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    buflen = sprintf(buf,&#34;%lld&#34;,sval);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                } else {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    buflen = slen;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    memcpy(buf,sstr,buflen);
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">                    buf[buflen] = &#39;</span><span style="color:#ae81ff">\0</span><span style="color:#960050;background-color:#1e0010">&#39;</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>                assert<span style="color:#f92672">(</span>memcmp<span style="color:#f92672">(</span>buf,listNodeValue<span style="color:#f92672">(</span>refnode<span style="color:#f92672">)</span>,buflen<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>            zfree<span style="color:#f92672">(</span>zl<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>            listRelease<span style="color:#f92672">(</span>ref<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;SUCCESS\n\n&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Stress with variable ziplist size:\n&#34;</span><span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        stress<span style="color:#f92672">(</span>ZIPLIST_HEAD,100000,16384,256<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>        stress<span style="color:#f92672">(</span>ZIPLIST_TAIL,100000,16384,256<span style="color:#f92672">)</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#endif</span>
</span></span></code></pre></div><h4 id="3参考文献">3.参考文献</h4>
<p>《<a href="https://github.com/Qinch/redis_reading/tree/4.0/src">redis_reading</a>》</p>
    </article>

    
<ul class="article-share">
</ul>


    <ul class="pager article-pager">
      <li class="pager-newer">
          <a href="/posts/makefile/" data-toggle="tooltip" data-placement="top" title="">&lt; Newer</a>
      </li>
      <li class="pager-older">
        <a href="/posts/bits-int/" data-toggle="tooltip" data-placement="top" title="24 bits解析为有符号整数">Older &gt;</a>
      </li>
    </ul>
  </div>


<div class="site-footer">
  <div class="copyright"></div>
  <ul class="site-footer-items">
    <li class="site-footer-item-"><a href="" title=""></a></li>
  </ul>
  <div class="powerdby">
    <a href="https://github.com/qinch" rel="me" target="_blank"><i class="fa-brands fa-github" style="font-size: 16px;"></i></a>&nbsp&nbsp
    <a href="mailto:qinchaowhut@qq.com" target="_blank"><i class="fa-solid fa-envelope" style="font-size: 16px;"></i></a></li><br>
    ©2015-2024 qinchao | Powered by <a href="https://gohugo.io/">Hugo</a> and <a href="https://github.com/taikii/whiteplain">Whiteplain</a>
  </div>
</div>

  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=Toracking%20ID"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'Toracking ID');
        }
      </script>
    
  



</body>
</html>
